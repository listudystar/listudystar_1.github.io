---
title: 机器学习-KNN（K近邻）
published: true
---

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

本文主要包括：1. KNN理论与算法；2. Airbnb房价预测案例；3. sklearn简介

# [](#header-1)KNN理论与算法

1. KNN的思路是：在数据集中找出K个与关注数据最接近的K个，之后平均，获得预测值或根据预测值分类；

2. KNN算法可以用于回归问题和分类问题【回归：预测值；分类：归类】；

3. 数据集被分为训练集和测试集，KNN的结果是得出每个测试集结果，即不需要训练，直接在训练集中找K近邻后，求平均；

4. 采用欧式距离确定最近；

<img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}" style="border:none;">

d=\sqrt[2]{(q_1-p_1)^2+(q_2-p_2)^2+\cdots+(q_n-p_n)^2}

式子中q1到qn是一条数据的所有特征信息，p1到pn是另一条数据的所有特征信息（即每条数据等可以计算得到）

5. 数据集的一般操作：数据集->洗牌->切分（训练集，验证集，测试集），因为KNN不需要训练，所以不需要验证集；

6. 对测试集进行验证，可以采用RMSE（均方根误差）
<p>
$d=\sqrt[2]{(actual_1-predicted_1)^2+(actual_2-predicted_2)^2+\cdots+(actual_n-predicted_n)^2}$
</p>
式子中将测试集的KNN预测值（predicted）与标签实际值(actual)求解RMSE值（n表示测试集的样本个数）

7. 数据的标准化和归一化->在KNN中使特征在计算欧式距离的平方时，不会出现很大的情况，即可以理解为各特征之间的标准要一致，不能偏袒于某个特征（不要大数值影响小数值特征）
标准化，要求均值u=0和标准差sigma=1，转换公式：
<p>
$$z=\frac{x-\mu}{\sigma}$$
</p>
归一化（0-1归一化），转换公式：
<p>
$$z=\frac{x-x_{min}}{x_{max}-x_{min}}$$
</p>
以上变换数据的分布不变，只是数值变化，所以可用；

## [](#header-2)Header 2

> This is a blockquote following a header.
>
> When something is important enough, you do it even if the odds are not in your favor.

### [](#header-3)Header 3

```js
// Javascript code with syntax highlighting.
var fun = function lang(l) {
  dateformat.i18n = require('./lang/' + l)
  return true;
}
```

```ruby
# Ruby code with syntax highlighting
GitHubPages::Dependencies.gems.each do |gem, version|
  s.add_dependency(gem, "= #{version}")
end
```

#### [](#header-4)Header 4

*   This is an unordered list following a header.
*   This is an unordered list following a header.
*   This is an unordered list following a header.

##### [](#header-5)Header 5

1.  This is an ordered list following a header.
2.  This is an ordered list following a header.
3.  This is an ordered list following a header.

###### [](#header-6)Header 6

| head1        | head two          | three |
|:-------------|:------------------|:------|
| ok           | good swedish fish | nice  |
| out of stock | good and plenty   | nice  |
| ok           | good `oreos`      | hmm   |
| ok           | good `zoute` drop | yumm  |

### There's a horizontal rule below this.

* * *

### Here is an unordered list:

*   Item foo
*   Item bar
*   Item baz
*   Item zip

### And an ordered list:

1.  Item one
1.  Item two
1.  Item three
1.  Item four

### And a nested list:

- level 1 item
  - level 2 item
  - level 2 item
    - level 3 item
    - level 3 item
- level 1 item
  - level 2 item
  - level 2 item
  - level 2 item
- level 1 item
  - level 2 item
  - level 2 item
- level 1 item

### Small image

![](https://assets-cdn.github.com/images/icons/emoji/octocat.png)

### Large image

![](https://guides.github.com/activities/hello-world/branching.png)


### Definition lists can be used with HTML syntax.

<dl>
<dt>Name</dt>
<dd>Godzilla</dd>
<dt>Born</dt>
<dd>1952</dd>
<dt>Birthplace</dt>
<dd>Japan</dd>
<dt>Color</dt>
<dd>Green</dd>
</dl>

```
Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this.
```

```
The final element.
```
